# Example PRD: Order Management Bounded Context
# ============================================
# This is a complete example showing how to write
# a DDD-aligned PRD for Task Master
# ============================================

## Project Name
E-Commerce Order Management System

## Business Context
We are building an order management system for an e-commerce platform.
The system handles the complete order lifecycle from creation to fulfillment.
This bounded context is responsible for order processing, not inventory
management or payment processing (those are separate contexts).

## Goals
- Enable customers to place orders with multiple items
- Support order status tracking throughout the lifecycle
- Provide order history and analytics
- Maintain order integrity with proper business rule validation

# ============================================
# BOUNDED CONTEXT: Order Management
# ============================================

## Primary Bounded Context
Name: Order Management
Description: Handles order creation, modification, and lifecycle management

### Context Boundaries

#### Included (In Scope):
- Order creation and validation
- Order item management
- Order status transitions
- Order pricing calculations
- Order history and queries

#### Excluded (Out of Scope):
- Inventory checking (Inventory Context - upstream)
- Payment processing (Payment Context - downstream)
- Customer management (Customer Context - upstream)
- Shipping logistics (Fulfillment Context - downstream)

### Related Contexts

| Context | Relationship | Integration Pattern |
|---------|--------------|---------------------|
| Inventory | Upstream | REST API (check availability) |
| Customer | Upstream | Shared Kernel (CustomerId) |
| Payment | Downstream | Domain Events (OrderConfirmed) |
| Fulfillment | Downstream | Domain Events (OrderReadyToShip) |

# ============================================
# UBIQUITOUS LANGUAGE
# ============================================

## Entities

| Entity | Definition | Properties | Invariants |
|--------|------------|------------|------------|
| Order | A customer's purchase request | orderId, customerId, status, items, totalAmount | Must have at least one item |
| OrderItem | A single product in an order | productId, quantity, unitPrice, subtotal | Quantity must be positive |

## Value Objects

| Value Object | Definition | Validation Rules |
|--------------|------------|------------------|
| OrderId | Unique identifier for an order | UUID format, immutable |
| CustomerId | Reference to customer context | UUID format, immutable |
| ProductId | Reference to product in inventory | UUID format, immutable |
| Money | Monetary amount with currency | Amount >= 0, valid currency code |
| Quantity | Number of items | Integer > 0 |
| OrderStatus | Current state of order | Enum: Pending, Confirmed, Shipped, Delivered, Cancelled |
| Address | Shipping/Billing address | Street, city, state, postalCode, country - all required |

## Aggregates

| Aggregate Root | Children | Invariants |
|----------------|----------|------------|
| Order | OrderItem[] | Order total must equal sum of item subtotals |
| | | Cannot modify after Confirmed status |
| | | Maximum 100 items per order |

## Domain Events

| Event | Trigger | Payload |
|-------|---------|---------|
| OrderCreated | New order placed | orderId, customerId, items, createdAt |
| OrderItemAdded | Item added to order | orderId, productId, quantity, price |
| OrderItemRemoved | Item removed from order | orderId, productId |
| OrderConfirmed | Customer confirms order | orderId, totalAmount, confirmedAt |
| OrderCancelled | Order is cancelled | orderId, reason, cancelledAt |
| OrderShipped | Order ships to customer | orderId, trackingNumber, shippedAt |
| OrderDelivered | Order delivered | orderId, deliveredAt |

## Domain Services

| Service | Purpose | Input | Output |
|---------|---------|-------|--------|
| OrderPricingService | Calculate order totals | Order, DiscountRules | PricingResult |

# ============================================
# FUNCTIONAL REQUIREMENTS BY LAYER
# ============================================

## Domain Layer Requirements

### Entities to Implement
- [ ] Order (Aggregate Root)
  - Method: create(customerId, items) - Creates new order
  - Method: addItem(productId, quantity, price) - Adds item
  - Method: removeItem(productId) - Removes item
  - Method: confirm() - Confirms order for processing
  - Method: cancel(reason) - Cancels order
  - Method: ship(trackingNumber) - Marks as shipped
  - Method: deliver() - Marks as delivered
  - Invariant: Must have at least one item
  - Invariant: Cannot modify after confirmation

- [ ] OrderItem (Entity)
  - Method: updateQuantity(newQuantity) - Updates quantity
  - Method: calculateSubtotal() - Returns quantity * unitPrice
  - Invariant: Quantity must be > 0

### Value Objects to Implement
- [ ] OrderId: UUID-based unique identifier
- [ ] Money: amount (decimal) + currency (string), immutable
- [ ] Quantity: positive integer, validated on creation
- [ ] OrderStatus: enum with valid transitions
- [ ] Address: validated shipping address

### Domain Events to Implement
- [ ] OrderCreatedEvent: Published when order is created
- [ ] OrderConfirmedEvent: Published when order is confirmed
- [ ] OrderCancelledEvent: Published when order is cancelled
- [ ] OrderShippedEvent: Published when order ships
- [ ] OrderDeliveredEvent: Published when order is delivered

## Application Layer Requirements

### Use Cases (Commands)

- [ ] CreateOrderUseCase
  - Input: customerId, items[{productId, quantity, price}]
  - Output: orderId
  - Steps:
    1. Validate customer exists (call Customer context)
    2. Create Order aggregate
    3. Save via OrderRepository
    4. Publish OrderCreatedEvent

- [ ] AddOrderItemUseCase
  - Input: orderId, productId, quantity, price
  - Output: Success/Failure
  - Steps:
    1. Load order from repository
    2. Call order.addItem()
    3. Save order
    4. Publish OrderItemAddedEvent

- [ ] ConfirmOrderUseCase
  - Input: orderId
  - Output: Success/Failure
  - Steps:
    1. Load order from repository
    2. Validate inventory availability (call Inventory context)
    3. Call order.confirm()
    4. Save order
    5. Publish OrderConfirmedEvent

- [ ] CancelOrderUseCase
  - Input: orderId, reason
  - Output: Success/Failure
  - Steps:
    1. Load order
    2. Validate can be cancelled
    3. Call order.cancel(reason)
    4. Save order
    5. Publish OrderCancelledEvent

### Use Cases (Queries)

- [ ] GetOrderByIdQuery
  - Input: orderId
  - Output: OrderDto

- [ ] GetCustomerOrdersQuery
  - Input: customerId, pagination
  - Output: PagedResult<OrderSummaryDto>

- [ ] GetPendingOrdersQuery
  - Input: pagination
  - Output: PagedResult<OrderSummaryDto>

## Infrastructure Layer Requirements

### Repositories to Implement
- [ ] SqlOrderRepository (implements OrderRepository)
  - Storage: PostgreSQL
  - Methods: save, findById, findByCustomerId, findPendingOrders
  - Mapper: OrderMapper (domain <-> database model)

### External Services
- [ ] CustomerServiceClient
  - Purpose: Validate customer exists
  - API: GET /api/customers/{id}

- [ ] InventoryServiceClient
  - Purpose: Check product availability
  - API: POST /api/inventory/check-availability

## Interface Layer Requirements

### REST API Endpoints
- [ ] POST /api/v1/orders - Create new order
  - Request: { customerId, items: [{productId, quantity, price}] }
  - Response: { orderId }

- [ ] GET /api/v1/orders/{id} - Get order by ID
  - Response: OrderDto

- [ ] POST /api/v1/orders/{id}/items - Add item to order
  - Request: { productId, quantity, price }
  - Response: { success: true }

- [ ] DELETE /api/v1/orders/{id}/items/{productId} - Remove item
  - Response: { success: true }

- [ ] POST /api/v1/orders/{id}/confirm - Confirm order
  - Response: { success: true }

- [ ] POST /api/v1/orders/{id}/cancel - Cancel order
  - Request: { reason }
  - Response: { success: true }

- [ ] GET /api/v1/orders - List orders with filters
  - Query: customerId, status, page, limit
  - Response: { items: OrderSummaryDto[], total, page }

# ============================================
# ARCHITECTURE CONSTRAINTS
# ============================================

## Dependency Rules (CRITICAL)
1. Order aggregate ONLY uses domain types (no database types)
2. OrderRepository interface defined in domain layer
3. SqlOrderRepository implements interface in infrastructure
4. Controllers use DTOs, never domain entities

## Layer Isolation
- OrderDto in interface layer for API responses
- OrderModel in infrastructure for database
- Order entity only in domain layer

## Event Guidelines
- Events published through Order aggregate's addDomainEvent()
- CreateOrderUseCase dispatches events after save
- Payment context listens to OrderConfirmedEvent

# ============================================
# ACCEPTANCE CRITERIA
# ============================================

## Testing Requirements
- [ ] Order aggregate unit tests (100% coverage)
- [ ] Value object validation tests
- [ ] Use case integration tests with mocked repos
- [ ] API endpoint E2E tests

## Architecture Validation
- [ ] npm run validate:layers passes
- [ ] No imports from infrastructure in domain
- [ ] All state changes publish events

## Documentation
- [ ] Order ubiquitous language added to docs
- [ ] API endpoints documented with OpenAPI
- [ ] Context map updated

# ============================================
# IMPLEMENTATION PHASES
# ============================================

## Phase 1: Domain Foundation (Priority: Highest)
- [ ] Implement Money, Quantity, OrderId value objects
- [ ] Implement OrderStatus with transitions
- [ ] Implement OrderItem entity
- [ ] Implement Order aggregate root
- [ ] Define all domain events

## Phase 2: Application Layer (Priority: High)
- [ ] Implement CreateOrderUseCase
- [ ] Implement AddOrderItemUseCase
- [ ] Implement ConfirmOrderUseCase
- [ ] Implement CancelOrderUseCase
- [ ] Implement GetOrderByIdQuery
- [ ] Implement GetCustomerOrdersQuery

## Phase 3: Infrastructure (Priority: Medium)
- [ ] Create database schema
- [ ] Implement OrderMapper
- [ ] Implement SqlOrderRepository
- [ ] Create CustomerServiceClient
- [ ] Create InventoryServiceClient

## Phase 4: Interface Layer (Priority: Medium)
- [ ] Create OrderController
- [ ] Implement all REST endpoints
- [ ] Add request validation
- [ ] Add error handling

## Phase 5: Testing & Polish (Priority: High)
- [ ] Write all unit tests
- [ ] Write integration tests
- [ ] Write E2E tests
- [ ] Performance testing
- [ ] Documentation

# ============================================
# NOTES
# ============================================

This example demonstrates:
1. Clear bounded context boundaries
2. Proper ubiquitous language definition
3. Layer-specific requirements
4. Architecture constraints enforcement
5. Phased implementation approach

Use this as a reference when creating your own PRD.
